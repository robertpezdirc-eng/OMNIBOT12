<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omni-APP Real-time Smart Dashboard</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            overflow-x: hidden;
            min-height: 100vh;
            color: #333;
        }

        #dashboard {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .node {
            border: 3px solid #2c3e50;
            border-radius: 12px;
            padding: 15px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            text-align: center;
            width: 180px;
            min-height: 80px;
            position: absolute;
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            user-select: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .node:active {
            cursor: grabbing;
            transform: scale(1.05) rotate(2deg);
        }

        .node:hover {
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.2);
        }

        .node.selected {
            border-color: #ff6b6b;
            background: linear-gradient(145deg, #ffe0e0, #ffcccb);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        .node.global {
            background: linear-gradient(145deg, #ffd700, #ffed4e);
            border-color: #f39c12;
            font-weight: bold;
            width: 200px;
            min-height: 100px;
        }

        .node.main-module {
            background: linear-gradient(145deg, #74b9ff, #0984e3);
            color: white;
            border-color: #2d3436;
        }

        .node.sub-module {
            background: linear-gradient(145deg, #a29bfe, #6c5ce7);
            color: white;
            border-color: #2d3436;
            width: 150px;
            min-height: 70px;
            font-size: 0.9em;
        }

        .node-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status {
            font-weight: bold;
            margin-top: 8px;
            display: block;
            font-size: 0.9em;
            padding: 4px 8px;
            border-radius: 15px;
            background: rgba(255,255,255,0.2);
        }

        .status.online { background: #2ecc71; color: white; }
        .status.warning { background: #f39c12; color: white; }
        .status.error { background: #e74c3c; color: white; }
        .status.offline { background: #95a5a6; color: white; }

        #links {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .link {
            stroke: #34495e;
            stroke-width: 3px;
            stroke-dasharray: 8,4;
            animation: dash 2s linear infinite;
            opacity: 0.7;
        }

        .link.active {
            stroke: #2ecc71;
            stroke-width: 4px;
            opacity: 1;
            filter: drop-shadow(0 0 5px #2ecc71);
        }

        .link.warning {
            stroke: #f39c12;
            stroke-width: 4px;
        }

        .link.error {
            stroke: #e74c3c;
            stroke-width: 4px;
        }

        @keyframes dash {
            to { stroke-dashoffset: 24; }
        }

        .flow-dot {
            r: 6;
            opacity: 0.9;
            filter: drop-shadow(0 0 3px currentColor);
        }

        .flow-dot.active { fill: #2ecc71; }
        .flow-dot.warning { fill: #f39c12; }
        .flow-dot.error { fill: #e74c3c; }
        .flow-dot.inactive { fill: #95a5a6; }

        #info-box {
            position: fixed;
            right: 20px;
            top: 20px;
            background: rgba(255,255,255,0.95);
            border: 2px solid #34495e;
            border-radius: 12px;
            padding: 20px;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #info-box h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }

        #controls {
            position: fixed;
            left: 20px;
            top: 20px;
            background: rgba(255,255,255,0.95);
            border: 2px solid #34495e;
            border-radius: 12px;
            padding: 20px;
            width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #controls h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }

        #controls input, #controls select {
            margin: 8px 0;
            width: 100%;
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            font-size: 14px;
        }

        #controls button {
            margin: 8px 0;
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        #statistics {
            position: fixed;
            left: 20px;
            bottom: 20px;
            background: rgba(255,255,255,0.95);
            border: 2px solid #34495e;
            border-radius: 12px;
            padding: 15px;
            width: 280px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        #statistics h4 {
            margin-top: 0;
            color: #2c3e50;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .connection-status {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: rgba(255,255,255,0.95);
            border: 2px solid #34495e;
            border-radius: 12px;
            padding: 15px;
            width: 250px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.online { background: #2ecc71; }
        .status-indicator.connecting { background: #f39c12; animation: pulse 1s infinite; }
        .status-indicator.offline { background: #e74c3c; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .keyboard-shortcuts {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 12px;
            display: none;
            z-index: 1000;
            max-width: 500px;
        }

        .keyboard-shortcuts.show {
            display: block;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 5px 0;
        }

        .shortcut-key {
            background: #34495e;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            #controls, #info-box {
                width: 280px;
                font-size: 14px;
            }
            
            .node {
                width: 140px;
                min-height: 60px;
                font-size: 0.9em;
            }
            
            .node.global {
                width: 160px;
                min-height: 80px;
            }
        }
    </style>
</head>
<body>
    <div id="dashboard">
        <svg id="links" width="100%" height="100vh"></svg>
        
        <!-- Global node -->
        <div class="node global" id="global" style="top:100px; left:50%; transform:translateX(-50%);">
            <div class="node-title">üåê Global Optimizer</div>
            <span class="status" id="status-global">‚è≥ Nalaganje...</span>
        </div>
    </div>

    <!-- Info Box -->
    <div id="info-box">
        <h3>üìä Informacije o modulu</h3>
        <p>Kliknite na modul za podrobnosti</p>
        <div id="module-details"></div>
    </div>

    <!-- Controls -->
    <div id="controls">
        <h3>üéõÔ∏è Nadzorna plo≈°ƒça</h3>
        
        <strong>Dodaj glavni modul:</strong>
        <input type="text" id="new-node-name" placeholder="Ime modula (npr. AI, IoT)"/>
        <input type="text" id="new-node-icon" placeholder="Emoji (npr. ü§ñ, üì°)"/>
        <button class="btn-primary" id="add-node">Dodaj modul</button>
        
        <strong>Dodaj podmodul:</strong>
        <select id="parent-module">
            <option value="">Izberi nadrejeni modul</option>
        </select>
        <input type="text" id="sub-node-name" placeholder="Ime podmodula"/>
        <input type="text" id="sub-node-icon" placeholder="Emoji"/>
        <button class="btn-success" id="add-sub-node">Dodaj podmodul</button>
        
        <hr style="margin: 15px 0;">
        
        <button class="btn-warning" id="auto-layout">üéØ Auto Layout</button>
        <button class="btn-primary" id="toggle-flows">üåä Preklopi Flow-e</button>
        <button class="btn-success" id="flow-burst">üí• Flow Burst</button>
        <button class="btn-danger" id="remove-selected">üóëÔ∏è Odstrani izbrani</button>
        <button class="btn-primary" id="reset-dashboard">üîÑ Reset</button>
        
        <hr style="margin: 15px 0;">
        
        <label>
            <input type="checkbox" id="enable-websocket" checked> WebSocket povezava
        </label>
        <label>
            <input type="checkbox" id="show-shortcuts"> Prika≈æi bli≈ænjice (H)
        </label>
    </div>

    <!-- Statistics -->
    <div id="statistics">
        <h4>üìà Statistike</h4>
        <div class="stat-item">
            <span>Glavni moduli:</span>
            <span id="main-modules-count">0</span>
        </div>
        <div class="stat-item">
            <span>Podmoduli:</span>
            <span id="sub-modules-count">0</span>
        </div>
        <div class="stat-item">
            <span>Aktivne povezave:</span>
            <span id="active-connections">0</span>
        </div>
        <div class="stat-item">
            <span>Flow paketi:</span>
            <span id="flow-packets">0</span>
        </div>
        <div class="stat-item">
            <span>Zadnji update:</span>
            <span id="last-update">-</span>
        </div>
    </div>

    <!-- Connection Status -->
    <div class="connection-status">
        <h4>üîó Povezava</h4>
        <div>
            <span class="status-indicator offline" id="ws-indicator"></span>
            <span id="ws-status">Offline</span>
        </div>
        <div style="margin-top: 10px; font-size: 0.9em;">
            <div>Backend: <span id="backend-status">Nedostopen</span></div>
            <div>Ping: <span id="ping-time">-</span></div>
        </div>
    </div>

    <!-- Keyboard Shortcuts -->
    <div class="keyboard-shortcuts" id="shortcuts-modal">
        <h3>‚å®Ô∏è Tipkovne bli≈ænjice</h3>
        <div class="shortcut-item">
            <span>Auto Layout</span>
            <span class="shortcut-key">A</span>
        </div>
        <div class="shortcut-item">
            <span>Reset Dashboard</span>
            <span class="shortcut-key">R</span>
        </div>
        <div class="shortcut-item">
            <span>Toggle Flow-i</span>
            <span class="shortcut-key">F</span>
        </div>
        <div class="shortcut-item">
            <span>Flow Burst</span>
            <span class="shortcut-key">B</span>
        </div>
        <div class="shortcut-item">
            <span>Odstrani izbrani</span>
            <span class="shortcut-key">Del</span>
        </div>
        <div class="shortcut-item">
            <span>Prekliƒçi izbor</span>
            <span class="shortcut-key">Esc</span>
        </div>
        <div class="shortcut-item">
            <span>Prika≈æi/skrij bli≈ænjice</span>
            <span class="shortcut-key">H</span>
        </div>
        <button class="btn-primary" onclick="toggleShortcuts()">Zapri</button>
    </div>

    <script>
        // Global variables
        let nodes = new Map();
        let connections = new Map();
        let selectedNode = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let flowAnimations = new Map();
        let websocket = null;
        let flowsEnabled = true;
        let statistics = {
            mainModules: 0,
            subModules: 0,
            activeConnections: 0,
            flowPackets: 0,
            lastUpdate: null
        };

        // Initialize dashboard
        function initDashboard() {
            console.log('üöÄ Inicializacija Omni-APP Smart Dashboard...');
            
            // Add global node to nodes map
            nodes.set('global', {
                id: 'global',
                element: document.getElementById('global'),
                type: 'global',
                status: 'loading',
                children: [],
                parent: null,
                position: { x: window.innerWidth / 2 - 100, y: 100 }
            });

            setupEventListeners();
            setupWebSocket();
            updateStatistics();
            
            // Auto layout after initialization
            setTimeout(() => {
                autoLayout();
                updateStatistics();
            }, 500);

            console.log('‚úÖ Dashboard inicializiran');
        }

        // Setup event listeners
        function setupEventListeners() {
            // Node interaction
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('click', handleClick);

            // Controls
            document.getElementById('add-node').addEventListener('click', addMainModule);
            document.getElementById('add-sub-node').addEventListener('click', addSubModule);
            document.getElementById('auto-layout').addEventListener('click', autoLayout);
            document.getElementById('toggle-flows').addEventListener('click', toggleFlows);
            document.getElementById('flow-burst').addEventListener('click', triggerFlowBurst);
            document.getElementById('remove-selected').addEventListener('click', removeSelected);
            document.getElementById('reset-dashboard').addEventListener('click', resetDashboard);
            document.getElementById('enable-websocket').addEventListener('change', toggleWebSocket);
            document.getElementById('show-shortcuts').addEventListener('change', (e) => {
                if (e.target.checked) toggleShortcuts();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);

            // Window resize
            window.addEventListener('resize', () => {
                updateSVGSize();
                autoLayout();
            });

            // Touch support
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        // Mouse event handlers
        function handleMouseDown(e) {
            if (e.target.classList.contains('node')) {
                isDragging = true;
                selectedNode = e.target.id;
                
                const rect = e.target.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                e.target.style.zIndex = '1000';
                updateNodeSelection();
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (isDragging && selectedNode) {
                const node = document.getElementById(selectedNode);
                if (node) {
                    const x = e.clientX - dragOffset.x;
                    const y = e.clientY - dragOffset.y;
                    
                    node.style.left = Math.max(0, Math.min(window.innerWidth - node.offsetWidth, x)) + 'px';
                    node.style.top = Math.max(0, Math.min(window.innerHeight - node.offsetHeight, y)) + 'px';
                    
                    // Update node position in data
                    if (nodes.has(selectedNode)) {
                        nodes.get(selectedNode).position = { x, y };
                    }
                    
                    updateConnections();
                }
            }
        }

        function handleMouseUp(e) {
            if (isDragging && selectedNode) {
                const node = document.getElementById(selectedNode);
                if (node) {
                    node.style.zIndex = '10';
                }
                isDragging = false;
            }
        }

        function handleClick(e) {
            if (e.target.classList.contains('node')) {
                selectedNode = e.target.id;
                updateNodeSelection();
                showNodeInfo(selectedNode);
            } else if (!e.target.closest('#controls') && !e.target.closest('#info-box')) {
                selectedNode = null;
                updateNodeSelection();
                showNodeInfo(null);
            }
        }

        // Touch event handlers
        function handleTouchStart(e) {
            if (e.target.classList.contains('node')) {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleMouseDown(mouseEvent);
                e.preventDefault();
            }
        }

        function handleTouchMove(e) {
            if (isDragging) {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleMouseMove(mouseEvent);
                e.preventDefault();
            }
        }

        function handleTouchEnd(e) {
            if (isDragging) {
                const mouseEvent = new MouseEvent('mouseup', {});
                handleMouseUp(mouseEvent);
                e.preventDefault();
            }
        }

        // Keyboard shortcuts
        function handleKeyboard(e) {
            if (e.target.tagName === 'INPUT') return;
            
            switch(e.key.toLowerCase()) {
                case 'a':
                    autoLayout();
                    break;
                case 'r':
                    resetDashboard();
                    break;
                case 'f':
                    toggleFlows();
                    break;
                case 'b':
                    triggerFlowBurst();
                    break;
                case 'delete':
                    removeSelected();
                    break;
                case 'escape':
                    selectedNode = null;
                    updateNodeSelection();
                    showNodeInfo(null);
                    break;
                case 'h':
                    toggleShortcuts();
                    break;
            }
        }

        // Add main module
        function addMainModule() {
            const name = document.getElementById('new-node-name').value.trim();
            const icon = document.getElementById('new-node-icon').value.trim();
            
            if (!name) {
                alert('Prosim vnesite ime modula');
                return;
            }

            const id = name.toLowerCase().replace(/\s+/g, '-');
            if (nodes.has(id)) {
                alert('Modul s tem imenom ≈æe obstaja');
                return;
            }

            createNode(id, `${icon} ${name}`, 'main-module', null);
            updateParentSelect();
            updateStatistics();
            
            // Clear inputs
            document.getElementById('new-node-name').value = '';
            document.getElementById('new-node-icon').value = '';
            
            // Auto layout after adding
            setTimeout(autoLayout, 100);
        }

        // Add sub module
        function addSubModule() {
            const parentId = document.getElementById('parent-module').value;
            const name = document.getElementById('sub-node-name').value.trim();
            const icon = document.getElementById('sub-node-icon').value.trim();
            
            if (!parentId || !name) {
                alert('Prosim izberite nadrejeni modul in vnesite ime podmodula');
                return;
            }

            const id = `${parentId}-${name.toLowerCase().replace(/\s+/g, '-')}`;
            if (nodes.has(id)) {
                alert('Podmodul s tem imenom ≈æe obstaja');
                return;
            }

            createNode(id, `${icon} ${name}`, 'sub-module', parentId);
            updateStatistics();
            
            // Clear inputs
            document.getElementById('sub-node-name').value = '';
            document.getElementById('sub-node-icon').value = '';
            
            // Auto layout after adding
            setTimeout(autoLayout, 100);
        }

        // Create node
        function createNode(id, title, type, parentId = null) {
            const dashboard = document.getElementById('dashboard');
            const nodeElement = document.createElement('div');
            
            nodeElement.className = `node ${type}`;
            nodeElement.id = id;
            nodeElement.innerHTML = `
                <div class="node-title">${title}</div>
                <span class="status" id="status-${id}">‚è≥ Inicializacija...</span>
            `;
            
            // Position node
            const x = Math.random() * (window.innerWidth - 200) + 100;
            const y = Math.random() * (window.innerHeight - 200) + 150;
            nodeElement.style.left = x + 'px';
            nodeElement.style.top = y + 'px';
            
            dashboard.appendChild(nodeElement);
            
            // Add to nodes map
            const nodeData = {
                id,
                element: nodeElement,
                type,
                status: 'initializing',
                children: [],
                parent: parentId,
                position: { x, y }
            };
            
            nodes.set(id, nodeData);
            
            // Update parent's children
            if (parentId && nodes.has(parentId)) {
                nodes.get(parentId).children.push(id);
            }
            
            // Create connection if has parent
            if (parentId) {
                createConnection(parentId, id);
            } else if (id !== 'global') {
                createConnection('global', id);
            }
            
            // Simulate status update
            setTimeout(() => {
                updateNodeStatus(id, 'online');
            }, 1000 + Math.random() * 2000);
            
            console.log(`‚úÖ Ustvarjen ${type}: ${title}`);
        }

        // Create connection
        function createConnection(fromId, toId) {
            const connectionId = `${fromId}-${toId}`;
            if (connections.has(connectionId)) return;
            
            const svg = document.getElementById('links');
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.classList.add('link');
            line.id = `link-${connectionId}`;
            
            svg.appendChild(line);
            
            connections.set(connectionId, {
                from: fromId,
                to: toId,
                element: line,
                active: false
            });
            
            updateConnections();
        }

        // Update connections
        function updateConnections() {
            connections.forEach((conn, id) => {
                const fromNode = nodes.get(conn.from);
                const toNode = nodes.get(conn.to);
                
                if (fromNode && toNode) {
                    const fromRect = fromNode.element.getBoundingClientRect();
                    const toRect = toNode.element.getBoundingClientRect();
                    
                    const x1 = fromRect.left + fromRect.width / 2;
                    const y1 = fromRect.top + fromRect.height / 2;
                    const x2 = toRect.left + toRect.width / 2;
                    const y2 = toRect.top + toRect.height / 2;
                    
                    conn.element.setAttribute('x1', x1);
                    conn.element.setAttribute('y1', y1);
                    conn.element.setAttribute('x2', x2);
                    conn.element.setAttribute('y2', y2);
                }
            });
        }

        // Auto layout
        function autoLayout() {
            console.log('üéØ Izvajam Auto Layout...');
            
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // Position global node at center top
            const globalNode = nodes.get('global');
            if (globalNode) {
                globalNode.element.style.left = (centerX - 100) + 'px';
                globalNode.element.style.top = '100px';
                globalNode.position = { x: centerX - 100, y: 100 };
            }
            
            // Get main modules (children of global)
            const mainModules = Array.from(nodes.values()).filter(n => 
                n.type === 'main-module' && n.parent === 'global'
            );
            
            // Position main modules in circle around global
            const radius = 300;
            const angleStep = (2 * Math.PI) / Math.max(mainModules.length, 1);
            
            mainModules.forEach((node, index) => {
                const angle = index * angleStep - Math.PI / 2; // Start from top
                const x = centerX + Math.cos(angle) * radius - 90;
                const y = centerY + Math.sin(angle) * radius - 40;
                
                node.element.style.left = Math.max(10, Math.min(window.innerWidth - 200, x)) + 'px';
                node.element.style.top = Math.max(10, Math.min(window.innerHeight - 100, y)) + 'px';
                node.position = { x, y };
                
                // Position sub-modules around their parent
                const subModules = node.children.map(id => nodes.get(id)).filter(Boolean);
                const subRadius = 150;
                const subAngleStep = (2 * Math.PI) / Math.max(subModules.length, 1);
                
                subModules.forEach((subNode, subIndex) => {
                    const subAngle = subIndex * subAngleStep;
                    const subX = x + Math.cos(subAngle) * subRadius;
                    const subY = y + Math.sin(subAngle) * subRadius;
                    
                    subNode.element.style.left = Math.max(10, Math.min(window.innerWidth - 180, subX)) + 'px';
                    subNode.element.style.top = Math.max(10, Math.min(window.innerHeight - 80, subY)) + 'px';
                    subNode.position = { x: subX, y: subY };
                });
            });
            
            updateConnections();
            console.log('‚úÖ Auto Layout dokonƒçan');
        }

        // Update node status
        function updateNodeStatus(nodeId, status) {
            const node = nodes.get(nodeId);
            if (!node) return;
            
            node.status = status;
            const statusElement = document.getElementById(`status-${nodeId}`);
            if (statusElement) {
                statusElement.className = `status ${status}`;
                
                switch(status) {
                    case 'online':
                        statusElement.textContent = '‚úÖ Online';
                        break;
                    case 'warning':
                        statusElement.textContent = '‚ö†Ô∏è Opozorilo';
                        break;
                    case 'error':
                        statusElement.textContent = '‚ùå Napaka';
                        break;
                    case 'offline':
                        statusElement.textContent = '‚≠ï Offline';
                        break;
                    default:
                        statusElement.textContent = '‚è≥ Nalaganje...';
                }
            }
        }

        // Update node selection
        function updateNodeSelection() {
            nodes.forEach(node => {
                node.element.classList.remove('selected');
            });
            
            if (selectedNode && nodes.has(selectedNode)) {
                nodes.get(selectedNode).element.classList.add('selected');
            }
        }

        // Show node info
        function showNodeInfo(nodeId) {
            const infoBox = document.getElementById('module-details');
            
            if (!nodeId || !nodes.has(nodeId)) {
                infoBox.innerHTML = '<p><em>Ni izbranega modula</em></p>';
                return;
            }
            
            const node = nodes.get(nodeId);
            const childrenCount = node.children.length;
            const parentName = node.parent ? nodes.get(node.parent)?.element.textContent : 'Ni';
            
            infoBox.innerHTML = `
                <h4>${node.element.querySelector('.node-title').textContent}</h4>
                <p><strong>ID:</strong> ${node.id}</p>
                <p><strong>Tip:</strong> ${node.type}</p>
                <p><strong>Status:</strong> ${node.status}</p>
                <p><strong>Nadrejeni:</strong> ${parentName}</p>
                <p><strong>Podmoduli:</strong> ${childrenCount}</p>
                <p><strong>Pozicija:</strong> (${Math.round(node.position.x)}, ${Math.round(node.position.y)})</p>
                ${node.children.length > 0 ? `
                    <p><strong>Seznam podmodulov:</strong></p>
                    <ul>
                        ${node.children.map(childId => {
                            const child = nodes.get(childId);
                            return `<li>${child ? child.element.querySelector('.node-title').textContent : childId}</li>`;
                        }).join('')}
                    </ul>
                ` : ''}
            `;
        }

        // Update parent select
        function updateParentSelect() {
            const select = document.getElementById('parent-module');
            select.innerHTML = '<option value="">Izberi nadrejeni modul</option>';
            
            nodes.forEach(node => {
                if (node.type === 'main-module' || node.type === 'global') {
                    const option = document.createElement('option');
                    option.value = node.id;
                    option.textContent = node.element.querySelector('.node-title').textContent;
                    select.appendChild(option);
                }
            });
        }

        // Toggle flows
        function toggleFlows() {
            flowsEnabled = !flowsEnabled;
            const button = document.getElementById('toggle-flows');
            button.textContent = flowsEnabled ? 'üåä Izklopi Flow-e' : 'üåä Vklopi Flow-e';
            
            if (flowsEnabled) {
                startFlowAnimations();
            } else {
                stopFlowAnimations();
            }
        }

        // Start flow animations
        function startFlowAnimations() {
            if (!flowsEnabled) return;
            
            connections.forEach((conn, id) => {
                if (Math.random() > 0.3) { // 70% chance of flow
                    animateFlow(conn.from, conn.to);
                }
            });
            
            // Continue animations
            setTimeout(startFlowAnimations, 2000 + Math.random() * 3000);
        }

        // Animate flow
        function animateFlow(fromId, toId) {
            const fromNode = nodes.get(fromId);
            const toNode = nodes.get(toId);
            
            if (!fromNode || !toNode || !flowsEnabled) return;
            
            const svg = document.getElementById('links');
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            
            // Random status
            const statuses = ['active', 'warning', 'error', 'inactive'];
            const status = statuses[Math.floor(Math.random() * statuses.length)];
            
            dot.classList.add('flow-dot', status);
            dot.setAttribute('r', '6');
            
            const fromRect = fromNode.element.getBoundingClientRect();
            const toRect = toNode.element.getBoundingClientRect();
            
            const startX = fromRect.left + fromRect.width / 2;
            const startY = fromRect.top + fromRect.height / 2;
            const endX = toRect.left + toRect.width / 2;
            const endY = toRect.top + toRect.height / 2;
            
            dot.setAttribute('cx', startX);
            dot.setAttribute('cy', startY);
            
            svg.appendChild(dot);
            
            // Animate
            const duration = 1000 + Math.random() * 2000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                
                dot.setAttribute('cx', currentX);
                dot.setAttribute('cy', currentY);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    svg.removeChild(dot);
                    statistics.flowPackets++;
                    updateStatistics();
                }
            }
            
            animate();
        }

        // Trigger flow burst
        function triggerFlowBurst() {
            console.log('üí• Flow Burst aktiviran!');
            
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    connections.forEach(conn => {
                        if (Math.random() > 0.5) {
                            animateFlow(conn.from, conn.to);
                        }
                    });
                }, i * 100);
            }
        }

        // Stop flow animations
        function stopFlowAnimations() {
            const dots = document.querySelectorAll('.flow-dot');
            dots.forEach(dot => dot.remove());
        }

        // Remove selected node
        function removeSelected() {
            if (!selectedNode || selectedNode === 'global') {
                alert('Izberite modul za odstranitev (Global se ne more odstraniti)');
                return;
            }
            
            const node = nodes.get(selectedNode);
            if (!node) return;
            
            // Remove children first
            [...node.children].forEach(childId => {
                removeNode(childId);
            });
            
            // Remove node
            removeNode(selectedNode);
            selectedNode = null;
            updateNodeSelection();
            showNodeInfo(null);
            updateStatistics();
        }

        // Remove node
        function removeNode(nodeId) {
            const node = nodes.get(nodeId);
            if (!node || nodeId === 'global') return;
            
            // Remove from parent's children
            if (node.parent && nodes.has(node.parent)) {
                const parent = nodes.get(node.parent);
                parent.children = parent.children.filter(id => id !== nodeId);
            }
            
            // Remove connections
            connections.forEach((conn, id) => {
                if (conn.from === nodeId || conn.to === nodeId) {
                    conn.element.remove();
                    connections.delete(id);
                }
            });
            
            // Remove element
            node.element.remove();
            nodes.delete(nodeId);
            
            updateParentSelect();
            console.log(`üóëÔ∏è Odstranjen modul: ${nodeId}`);
        }

        // Reset dashboard
        function resetDashboard() {
            if (confirm('Ali ste prepriƒçani, da ≈æelite resetirati dashboard?')) {
                // Remove all nodes except global
                const nodeIds = Array.from(nodes.keys()).filter(id => id !== 'global');
                nodeIds.forEach(id => removeNode(id));
                
                // Reset global status
                updateNodeStatus('global', 'online');
                
                // Clear statistics
                statistics = {
                    mainModules: 0,
                    subModules: 0,
                    activeConnections: 0,
                    flowPackets: 0,
                    lastUpdate: new Date()
                };
                
                updateStatistics();
                updateParentSelect();
                
                console.log('üîÑ Dashboard resetiran');
            }
        }

        // Update statistics
        function updateStatistics() {
            const mainModules = Array.from(nodes.values()).filter(n => n.type === 'main-module').length;
            const subModules = Array.from(nodes.values()).filter(n => n.type === 'sub-module').length;
            const activeConnections = connections.size;
            
            statistics.mainModules = mainModules;
            statistics.subModules = subModules;
            statistics.activeConnections = activeConnections;
            statistics.lastUpdate = new Date();
            
            document.getElementById('main-modules-count').textContent = mainModules;
            document.getElementById('sub-modules-count').textContent = subModules;
            document.getElementById('active-connections').textContent = activeConnections;
            document.getElementById('flow-packets').textContent = statistics.flowPackets;
            document.getElementById('last-update').textContent = statistics.lastUpdate.toLocaleTimeString();
        }

        // WebSocket functions
        function setupWebSocket() {
            if (!document.getElementById('enable-websocket').checked) return;
            
            try {
                websocket = new WebSocket('ws://localhost:8080');
                
                websocket.onopen = function() {
                    console.log('üîó WebSocket povezan');
                    updateConnectionStatus('online', 'Povezan');
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (e) {
                        console.error('Napaka pri parsiranju WebSocket sporoƒçila:', e);
                    }
                };
                
                websocket.onclose = function() {
                    console.log('üîå WebSocket povezava zaprta');
                    updateConnectionStatus('offline', 'Prekinjena');
                    
                    // Auto reconnect
                    setTimeout(setupWebSocket, 5000);
                };
                
                websocket.onerror = function(error) {
                    console.error('WebSocket napaka:', error);
                    updateConnectionStatus('offline', 'Napaka');
                };
                
            } catch (e) {
                console.error('Napaka pri vzpostavljanju WebSocket povezave:', e);
                updateConnectionStatus('offline', 'Nedostopen');
            }
        }

        // Handle WebSocket message
        function handleWebSocketMessage(data) {
            if (data.type === 'flow_update') {
                // Update module statuses
                if (data.modules) {
                    data.modules.forEach(module => {
                        if (nodes.has(module.id)) {
                            const status = module.status.includes('Online') ? 'online' :
                                         module.status.includes('Warning') ? 'warning' :
                                         module.status.includes('Error') ? 'error' : 'offline';
                            updateNodeStatus(module.id, status);
                        }
                    });
                }
                
                // Animate flows
                if (data.flows && flowsEnabled) {
                    data.flows.forEach(flow => {
                        if (flow.active && nodes.has(flow.from) && nodes.has(flow.to)) {
                            animateFlow(flow.from, flow.to);
                        }
                    });
                }
                
                updateStatistics();
            }
        }

        // Toggle WebSocket
        function toggleWebSocket() {
            if (document.getElementById('enable-websocket').checked) {
                setupWebSocket();
            } else {
                if (websocket) {
                    websocket.close();
                    websocket = null;
                }
                updateConnectionStatus('offline', 'Onemogoƒçen');
            }
        }

        // Update connection status
        function updateConnectionStatus(status, message) {
            const indicator = document.getElementById('ws-indicator');
            const statusText = document.getElementById('ws-status');
            const backendStatus = document.getElementById('backend-status');
            
            indicator.className = `status-indicator ${status}`;
            statusText.textContent = message;
            
            switch(status) {
                case 'online':
                    backendStatus.textContent = 'Dostopen';
                    document.getElementById('ping-time').textContent = '< 50ms';
                    break;
                case 'connecting':
                    backendStatus.textContent = 'Povezovanje...';
                    document.getElementById('ping-time').textContent = '-';
                    break;
                default:
                    backendStatus.textContent = 'Nedostopen';
                    document.getElementById('ping-time').textContent = '-';
            }
        }

        // Toggle shortcuts modal
        function toggleShortcuts() {
            const modal = document.getElementById('shortcuts-modal');
            modal.classList.toggle('show');
        }

        // Update SVG size
        function updateSVGSize() {
            const svg = document.getElementById('links');
            svg.setAttribute('width', window.innerWidth);
            svg.setAttribute('height', window.innerHeight);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initDashboard();
            updateSVGSize();
            
            // Start flow animations
            setTimeout(() => {
                if (flowsEnabled) {
                    startFlowAnimations();
                }
            }, 2000);
        });

        // Handle page visibility change
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                stopFlowAnimations();
            } else if (flowsEnabled) {
                startFlowAnimations();
            }
        });

        console.log('üöÄ Omni-APP Smart Dashboard pripravljen!');
    </script>
</body>
</html>